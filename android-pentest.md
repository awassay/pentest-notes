## Reversing APKs
- Use apktool to decompile the APK
```sh
apktool -d app.apk
```
- We can repack APKs using apktool b and the resulting .apk will be written to the ./dist folder. But we need to sign it!
```sh
cd ./app.apk/
apktool b
```
- To sign the APK, we need to create a keystore which will contain our signing key. To create a testing.keystore with a key named test_key, use keytool
```sh
keytool -genkey -v -keystore testing.keystore -alias test_key -keyalg RSA -keysize 2048 -validity 10000
```
- To sign an APK we use jarsigner
```sh
jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore testing.keystore ./dist/app.apk test_key
# On newer Android versions SHA1 signatures still get rejected. In that case simply use the default algorithms
jarsigner -verbose -keystore testing.keystore app.apk test_key
```
- Errors when signing apks:
  - INSTALL_PARSE_FAILED_NO_CERTIFICATES: There is still something wrong with the signature. &rarr; Maybe you tried to install an unsigned apk or the chosen algorithm (eg. SHA1) gets rejected.
  - INSTALL_FAILED_INVALID_APK: Failed to extract native libraries &rarr; This error occurs with some versions of apktool if the app contains native-libraries. To fix it, edit the AndroidManifest.xml so that extractNativeLibs is set to true. Afterwards you need to repackage and re-sign your APK.
  - INSTALL_FAILED_UPDATE_INCOMPATIBLE: Package io.hextree.reversingexample signatures do not match previously installed version; ignoring! &rarr; You will get this message if a version of the app signed with a different key is installed on the device. The simple solution is to delete the existing app.
  - Failed parse during installPackageLI: Targeting R+ (version 30 and above) requires the resources.arsc of installed APKs to be stored uncompressed and aligned on a 4-byte boundary.
    - This happens on newer apps, try this alternative method using zipalign and apksigner coming with the specific version build tools:
      ```sh
      apktool b
      C:\Users\[user]\AppData\Local\Android\sdk\build-tools\34.0.0\zipalign -p -f -v 4 ./dist/<apktool_build>.apk aligned.apk
      C:\Users\[user]\AppData\Local\Android\sdk\build-tools\34.0.0\apksigner sign --ks ./testing.keystore ./aligned.apk
      ```
## Network Interception
1. **Installing System Certificate: (Android 9+) (Rooted Device Needed)** Due to the default network security config rules, most apps only trust "system" certificates. The default configuration for apps targeting **Android 9 (API level 28) and higher** is as follows:
  ```
  <base-config cleartextTrafficPermitted="false">
      <trust-anchors>
          <certificates src="system" />
      </trust-anchors>
  </base-config>
  ```
  - Install the proxy certificate as a regular user certificate
  - Ensure you are root (adb root), and execute the following commands in adb shell:
    ```sh
    # Backup the existing system certificates to the user certs folder
    cp /system/etc/security/cacerts/* /data/misc/user/0/cacerts-added/
    
    # Create the in-memory mount on top of the system certs folder
    mount -t tmpfs tmpfs /system/etc/security/cacerts
    
    # copy all system certs and our user cert into the tmpfs system certs folder
    cp /data/misc/user/0/cacerts-added/* /system/etc/security/cacerts/
    
    # Fix any permissions & selinux context labels
    chown root:root /system/etc/security/cacerts/*
    chmod 644 /system/etc/security/cacerts/*
    chcon u:object_r:system_file:s0 /system/etc/security/cacerts/*
    ```
- **Note:** There have been significant changes in **Android 14** in the way how the system certificates are handled. For Android 14, follow this blog [New ways to inject system CA certificates in Android 14](https://httptoolkit.com/blog/android-14-install-system-ca-certificate/)
2. **Patching the APK: (No root needed)** We can use apktool to patch the APK and add network security config that allows app to trust user certificates.
  - Decompile the APK, add network security config in Manifest file and then Add the XML file. Finally rebuild the APK.
  ```sh
  # unpack the target .apk
  apktool d app.apk
  
  # modify the AndroidManifest.xml to add a networkSecurityConfig
  <application android:networkSecurityConfig="@xml/network_security_config"/>
  # create a permissive xml/network_security_config.xml -> see following 
  cd app
  
  # repackage the .apk
  apktool b
  
  # ensure the .apk is zipaligned
  C:\Users\[user]\AppData\Local\Android\sdk\build-tools\34.0.0\zipalign -p -f -v 4 ./dist/app.apk app2.apk
  
  # create a keystore to sign the apk
  keytool -genkey -v -keystore research.keystore -alias research_key -keyalg RSA -keysize 2048 -validity 10000
  
  # sign the apk with apksigner
  C:\Users\[user]\AppData\Local\Android\sdk\build-tools\34.0.0\apksigner sign --ks ./research.keystore ./app2.apk
  ```
  - Add following config in `res/xml/network_security_config.xml` file:
  ```xml
  <network-security-config>
      <base-config>
          <trust-anchors>
              <certificates src="user"/>
              <certificates src="system"/>
          </trust-anchors>
      </base-config>
  </network-security-config>
  ```
3. **Using VPN to Intercept Traffic:** For this purpose we can use the open source [rethink app](https://github.com/celzero/rethink-app).
  - Change DNS settings to "System DNS"
  - Add a HTTP(S) CONNECT proxy
  - Start the "VPN". Also make sure you have your proxy certificate installed in the system certs store.
4. **DNS Spoofing and Transparent Proxy:**
    1. **Setup dnsmasq:**
     We need some kind of DNS server where we can control the IP. Example dnsmasq.conf:
     ```
    address=/hextree.io/192.168.178.37
    address=/ht-api-mocks-lcfc4kr5oa-uc.a.run.app/192.168.178.37
    log-queries
     ```
    2. **Then run dnsmasq with docker:**
    ```sh
    docker pull andyshinn/dnsmasq
    docker run --name my-dnsmasq --rm -it -p 0.0.0.0:53:53/udp \
     -v D:\tmp\proxy\dnsmasq.conf:/etc/dnsmasq.conf andyshinn/dnsmasq.conf andyshinn/dnsmasq
    ```
    3. **Configure DNS Server:** 
    In order to force apps to use our DNS service, we can make use of the Android VPN feature. Using for example the rethinkdns app we can control this.
    - Change DNS settings to "Other DNS"
    - Select "Proxy DNS"
    - Create a new entry pointing at your local DNS server host
    - You can check whether DNS spoofing works by going to Google Chrome and visit `chrome://net-internals`.

    4. **Invisible Proxy Setup:**
     - Configure your proxy tool with invisible/transparent proxying. In this mode Burp will essentially act as a full HTTP(S) server, parse the HOST header and forward the requests accordingly.
     - Make sure you have an invisible proxy listener on port 443 and 80
